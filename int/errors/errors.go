// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

// Package errors provides some internal error types and utilities.
package errors

import (
	"errors"
	"fmt"
	"net/http"
	"regexp"
	"strconv"
	"strings"
)

// CompositeError represents an HTTP status, encoded in the first byte as the
// status - 400, plus the error message.
type CompositeError string

func (c CompositeError) Error() string {
	return "kivik: " + string(c[4:])
}

// HTTPStatus returns c's HTTP status code.
func (c CompositeError) HTTPStatus() int {
	i, _ := strconv.Atoi(string(c[:3]))
	return i
}

// Error represents an error returned by Kivik.
//
// This type definition is not guaranteed to remain stable, or even exported.
// When examining errors programmatically, you should rely instead on the
// HTTPStatus() function in this package, rather than on directly observing
// the fields of this type.
type Error struct {
	// Status is the HTTP status code associated with this error. Normally
	// this is the actual HTTP status returned by the server, but in some cases
	// it may be generated by Kivik directly.
	Status int

	// Message is the error message.
	Message string

	// Err is the originating error, if any.
	Err error
}

var (
	_ error       = &Error{}
	_ statusCoder = &Error{}
)

func (e *Error) Error() string {
	if e.Err == nil {
		return e.msg()
	}
	if e.Message == "" {
		return e.Err.Error()
	}
	return e.Message + ": " + e.Err.Error()
}

// HTTPStatus returns the HTTP status code associated with the error, or 500
// (internal server error), if none.
func (e *Error) HTTPStatus() int {
	if e.Status == 0 {
		return http.StatusInternalServerError
	}
	return e.Status
}

// Unwrap satisfies the errors wrapper interface.
func (e *Error) Unwrap() error {
	return e.Err
}

// Format implements [fmt.Formatter].
func (e *Error) Format(f fmt.State, c rune) {
	const partsLen = 3
	parts := make([]string, 0, partsLen)
	if e.Message != "" {
		parts = append(parts, e.Message)
	}
	if c == 'v' {
		if f.Flag('+') {
			parts = append(parts, fmt.Sprintf("%d / %s", e.Status, http.StatusText(e.Status)))
		}
	}
	if e.Err != nil {
		parts = append(parts, e.Err.Error())
	}
	_, _ = fmt.Fprint(f, strings.Join(parts, ": "))
}

func (e *Error) msg() string {
	switch e.Message {
	case "":
		return http.StatusText(e.HTTPStatus())
	default:
		return e.Message
	}
}

type statusCoder interface {
	HTTPStatus() int
}

// HTTPStatus returns the HTTP status code embedded in the error, or 500
// (internal server error), if there was no specified status code.  If err is
// nil, HTTPStatus returns 0.
func HTTPStatus(err error) int {
	if err == nil {
		return 0
	}
	if errors.Is(err, errUnsupported) {
		return http.StatusNotImplemented
	}
	var coder statusCoder
	for {
		if errors.As(err, &coder) {
			return coder.HTTPStatus()
		}
		if uw := errors.Unwrap(err); uw != nil {
			err = uw
			continue
		}
		return http.StatusInternalServerError
	}
}

// StatusErrorDiff returns the empty string if the expected error string and
// status match err. Otherwise, it returns a description of the mismatch.
func StatusErrorDiff(wantErr string, wantStatus int, err error) string {
	var (
		msg    string
		status int
	)
	if err != nil {
		status = HTTPStatus(err)
		msg = err.Error()
	}
	if msg != wantErr || status != wantStatus {
		return fmt.Sprintf("Unexpected error: %s [%d] (expected: %s [%d])",
			err, status, wantErr, wantStatus)
	}
	return ""
}

// StatusErrorDiffRE returns the empty string if the expected error RE and
// status match err. Otherwise, it returns a description of the mismatch.
func StatusErrorDiffRE(wantErrRE string, wantStatus int, err error) string {
	re := regexp.MustCompile(wantErrRE)
	var (
		msg    string
		status int
	)
	if err != nil {
		status = HTTPStatus(err)
		msg = err.Error()
	}
	if !re.MatchString(msg) || status != wantStatus {
		return fmt.Sprintf("Unexpected error: %s [%d] (expected: %s [%d])",
			err, status, re, wantStatus)
	}
	return ""
}
